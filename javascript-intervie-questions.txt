𝗝𝗮𝘃𝗮𝗦𝗰𝗿𝗶𝗽𝘁 𝗖𝗼𝗿𝗲:
1. Closures & Scope
2. Event Loop & Async
3. Promises & Async/Await
4. Hoisting & This Keyword
5. Prototypes & Inheritance
6. Event Delegation & Bubbling
7. Debouncing & Throttling

1. What is the difference between var, let, and const in JavaScript?
 2. What are closures in JavaScript, and how do they work?
 3. What is the this keyword in JavaScript, and how does it behave in different contexts?
 4. What is a JavaScript promise, and how does it handle asynchronous code?
 5. What is the event loop, and how does JavaScript handle asynchronous operations?
 6. What is hoisting in JavaScript, and how does it work?
 7. What are JavaScript data types, and how do you check the type of a variable?
 8. What is the difference between null and undefined in JavaScript?
 9. What is a callback function, and how is it used?
 10. How do you manage errors in JavaScript?
 11. What is the difference between setTimeout() and setInterval()?
 12. How do JavaScript promises work, and what is the then() method?
 13. What is async/await, and how does it simplify asynchronous code in JavaScript?
 14. What are the advantages of using async functions over callbacks?
 15. How do you handle multiple promises simultaneously?
 16. What are higher-order functions in JavaScript, and can you provide an example?
 17. What is destructuring in JavaScript, and how is it useful?
 18. What are template literals in JavaScript, and how do they work?
 19. How does the spread operator work in JavaScript?
 20. What is the rest parameter in JavaScript, and how does it differ from the arguments object?
 21. What is the difference between an object and an array in JavaScript?
 22. How do you clone an object or array in JavaScript?
 23. What are object methods like Object.keys(), Object.values(), and Object.entries()?
 24. How does the map() method work in JavaScript, and when would you use it?
 25. What is the difference between map() and forEach() in JavaScript?
 26. What is event delegation in JavaScript, and why is it useful?
 27. What are JavaScript modules, and how do you import/export them?
 28. What is the prototype chain in JavaScript, and how does inheritance work?
 29. What is bind(), call(), and apply() in JavaScript, and when do you use them?
 30. How does JavaScript handle equality comparisons with == and ===?
 
 
 Javascript Interview:-
1. Implement a counter in JavaScript.
 - How would you handle increment, decrement, and reset?
 - What about maintaining state across multiple buttons?

2. Recreate Function.prototype.call().
 - How would you bind the correct this context?
 - How do you handle arguments dynamically?

3. Recreate Function.prototype.apply().
 - How is it different from call()?
 - How do you spread array arguments safely?

4. Recreate Function.prototype.bind().
 - How do you ensure the returned function remembers context?
 - How would you handle partial application of arguments?

5. Implement a debounce function.
 - How would you cancel a pending call?
 - Where is debounce useful in real-world apps?

6. Implement a throttle function.
 - How would you support both leading and trailing options?
 - Where would throttle be preferred over debounce?

7. Implement an Event Emitter.
 - How would you implement on, off, and once?
 - How would you handle error propagation?

8. Implement a Promise.all polyfill.
 - How do you handle one rejection?
 - How do you deal with an empty array?

9. Implement a Promise.race polyfill.
 - How do you return the first settled promise?
 - How would you handle rejections?

10. Implement a flatten array function.
 - How would you flatten nested arrays of arbitrary depth?
 - How do you optimize for very large arrays?

11. Implement a deep clone function.
 - How would you handle nested objects, arrays, and dates?
 - How would you deal with circular references?

12. Implement a deep equality check.
 - How would you compare arrays vs objects?
 - How would you handle edge cases like NaN or null?

13. Implement a memoization function.
 - How would you cache expensive computations?
 - How would you handle cache invalidation?

14. Implement a once() function.
 - How do you ensure the function executes only once?
 - Would you return the first computed result on later calls?

15. Implement a function to check for balanced brackets.
 - How would you extend to {}, [], and <>?
 - How do you handle invalid orders?

16. Implement a function to check anagrams.
 - How would you optimize for very large strings?
 - How do you handle Unicode characters?

17. Implement a curry function.
 - How would you handle multiple parameters?
 - What about optional arguments?

18. Implement a LRU Cache.
 - How would you implement eviction?
 - What data structures would you use internally?

19. Reverse a linked list in JavaScript.
 - How would you do it iteratively vs recursively?
 - What about stack safety in large lists?

20. Implement image lazy loading.
 - How would you detect when images enter the viewport?
 - What placeholder strategies would you use (blur/skeleton)?

🍄 Chain Calculator
🍄 Promises in Sequence
🍄 Pipe and Compose
🍄 Array Polyfills (map, filter, reduce, etc.)
🍄 Prototype and Prototype Inheritance
🍄 Call, Apply, Bind
🍄 Flatten Array
🍄 Basic Debouncing
🍄 Basic Throttling
🍄 Event Emitter
🍄 Debouncing with Leading and Trailing Options
🍄 MapLimit (Controlling Concurrent Asynchronous Calls)
🍄 Cancelable Promise
🍄 Typeahead Search with LRU Cache
🍄 Document Comparison
🍄 Currying
🍄 Execute Tasks in Parallel
🍄 Sorting an Array 
🍄 Object Flattening
🍄 Deep Clone Object
🍄 JSON.stringify vs Manual Deep Copy
🍄 React DOM Rendering Process
🍄 Retry Promises N Times
🍄 Extended Version of Event Emitter
🍄 Promise.all
🍄 Promise.race
🍄 Promise.any
🍄 Promise.allSettled
